package td3;/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import td3.commandes.DAO;
import td3.commandes.Commande;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import td3.commandes.Categorie;
import td3.commandes.Produit;
import td3.paires.Paire;
import td3.universite.Etudiant;
import td3.universite.Matiere;
import td3.universite.Annee;
import td3.universite.UE;

import static sun.security.util.Debug.args;

public class App {

    public static void question3() {
        DAO data = DAO.instance();
        data.commandes().forEach(System.out::println);
        data.commandes().stream().map(Commande::normaliser).forEach(System.out::println);
        // produits
        System.out.println(data.produits());
        // produits à TVA réduite (3 versions)
        System.out.println(data.selectionProduits(p -> p.cat() == Categorie.REDUIT));
        System.out.println(data.selectionProduits(p -> App.aTauxReduit(p)));
        System.out.println(data.selectionProduits(App::aTauxReduit));
        // produits à TVA réduite coûtant plus de 5 EUR
        System.out.println(data.selectionProduits(p -> p.cat() == Categorie.REDUIT && p.prix() > 5.0));
        // commandes de plus de 2 items
        System.out.println(data.selectionCommande(c -> c.lignes().size() > 2));
        // commandes contenant au moins un produit à TVA réduite commandé en plus de 2
        // exemplaires
        System.out.println(
                data.selectionCommandeSurExistanceLigne(l -> l.fst().cat() == Categorie.REDUIT && l.snd() > 2));
        // affichage des commandes sans réduction (REFACTORE)
        Function<Commande, String> reprSimple = c -> c.affiche(App::calculSimple);
        Function<Commande, String> reprReduction = c -> c.affiche(App::calculReduction);
        data.commandes().stream().map(reprSimple).forEach(System.out::println);
        data.commandes().stream().map(reprReduction).forEach(System.out::println);
    }

    public static Boolean aTauxReduit(Produit p) {
        return p.cat() == Categorie.REDUIT;
    }


    public static Double calculSimple(Paire<Produit, Integer> ligne) {
        Produit p = ligne.fst();
        int qte = ligne.snd();
        return p.prix() * (1 + p.cat().tva()) * qte;
    }

    public static Double calculReduction(Paire<Produit, Integer> ligne) {
        Double reduction = (ligne.snd() > 2) ? ligne.fst().prix() : 0.0;
        return calculSimple(ligne) - reduction;
    }


    public static void afficheSi(String entete, Predicate<Etudiant> filtre, Annee a) {
        System.out.println(String.format("\n**%s\n", entete));
        a.etudiants().stream().filter(filtre).forEach(System.out::println);
    }

    public static void afficheSiv2(String entete, Predicate<Etudiant> filtre, Annee a,
                                   Function<Etudiant, String> repr) {
        System.out.println(String.format("\n**%s\n", entete));
        a.etudiants().stream().filter(filtre).map(repr).forEach(System.out::println);
    }

    public static final Function<Annee, Stream<Matiere>> matieresA = a -> a.ues().stream()
            .flatMap(ue -> ue.ects().keySet().stream());

    public static final Function<Etudiant, Stream<Matiere>> matieresE = e -> matieresA.apply(e.annee());

    public static final Function<Etudiant, Stream<Entry<Matiere, Integer>>> matieresCoefE_ = e -> e.annee().ues()
            .stream().flatMap(ue -> ue.ects().entrySet().stream());

    public static final Function<Entry<Matiere, Integer>, Paire<Matiere, Integer>> entry2paire = e -> new Paire<>(
            e.getKey(), e.getValue());

    public static final Function<Etudiant, Stream<Paire<Matiere, Integer>>> matieresCoefE = e -> matieresCoefE_.apply(e)
            .map(entry2paire);

    public static final Predicate<Etudiant> aDEF = e -> matieresE.apply(e).anyMatch(m -> !e.notes().containsKey(m));

    public static final double PLANCHER = 6.0;
    public static final Predicate<Etudiant> aNoteEliminatoire = e -> e.notes().values().stream()
            .anyMatch(note -> note < PLANCHER);

    public static final BinaryOperator<Paire<Double, Integer>> accumulateurMoyenne = (acc,
                                                                                      nv) -> new Paire<>(acc.fst() + nv.fst() * nv.snd(), acc.snd() + nv.snd());

    public static final Paire<Double, Integer> zero = new Paire<>(0.0, 0);

    // notesPonderees : Etudiant -> [(Double, Integer)]
    // obtention de la liste de (note, coef) pour les matières d'un étudiant
    // peut avoir null pour la note si l'étudiant est DEF dans cette note
    public static final Function<Etudiant, List<Paire<Double, Integer>>> notesPonderees = e -> matieresCoefE.apply(e)
            .map(p -> new Paire<>(e.notes().get(p.fst()), p.snd())).collect(Collectors.toList());

    // notesPondereesIndicatives : Etudiant -> [(Double, Integer)]
    // obtention de la liste de (note, coef) pour les matières d'un étudiant
    // si l'étudiant est DEF dans cette note on utilise 0.0
    public static final Function<Etudiant, List<Paire<Double, Integer>>> notesPondereesIndicatives = e -> matieresCoefE
            .apply(e).map(p -> new Paire<>((e.notes().containsKey(p.fst())) ? (e.notes().get(p.fst())) : 0.0, p.snd()))
            .collect(Collectors.toList());

    // reduit : [(Double, Integer)] -> (Double, Integer)
    // replie avec l'accumulateur spécifique
    public static final Function<List<Paire<Double, Integer>>, Paire<Double, Integer>> reduit = ps -> ps.stream()
            .reduce(zero, accumulateurMoyenne);

    // divise : (Double, Integer) -> Double
    // calcule la moyenne à partir d'un couple (somme pondérée, somme coefs)
    public static final Function<Paire<Double, Integer>, Double> divise = p -> p.fst() / p.snd();

    public static final Function<Etudiant, Double> computeMoyenne = notesPonderees.andThen(reduit).andThen(divise);

    public static final Function<Etudiant, Double> computeMoyenneIndicative = notesPondereesIndicatives.andThen(reduit).andThen(divise);

    // calcul de moyenne (sert uniquement pour précondition à computeMoyenne)
    public static final Function<Etudiant, Double> moyenne = e -> (e == null || aDEF.test(e)) ? null
            : computeMoyenne.apply(e);

    // calcul de moyenne (inutile mais là pour montrer la différence)
    public static final Function<Etudiant, Double> moyenneIndicative = computeMoyenneIndicative;

    // plante si moyenne ne peut pas être calculée (on réécrira plus tard)
    public static final Predicate<Etudiant> naPasLaMoyennev1 = e -> moyenne.apply(e) < 10.0;

    // ne plante pas mais teste explicitement null (on réécrira plus tard)
    public static final Predicate<Etudiant> naPasLaMoyennev2 = e -> {
        Double m = moyenne.apply(e);
        return ((m == null) || (m < 10.0));
    };

    // permet différents calculs de moyenne
    public static final Function<Function<Etudiant, Double>, Predicate<Etudiant>> naPasLaMoyenneGeneralise = f -> e -> {
        Double m = f.apply(e);
        return ((m == null) || (m < 10.0));
    };

    // plante si la moyenne ne peut pas être calculée (naPasLaMoyenne évalué avant
    // aDef)
    public static final Predicate<Etudiant> session2v1 = naPasLaMoyennev1.or(aDEF).or(aNoteEliminatoire);

    // ne plante pas (aDEF évalué avant naPasLaMoyenne)
    public static final Predicate<Etudiant> session2v2 = aDEF.or(aNoteEliminatoire).or(naPasLaMoyennev1);

    public static void ex2() {
        Matiere m1 = new Matiere("MAT1");
        Matiere m2 = new Matiere("MAT2");
        UE ue1 = new UE("UE1", Map.of(m1, 2, m2, 2));
        Matiere m3 = new Matiere("MAT3");
        UE ue2 = new UE("UE2", Map.of(m3, 1));
        Annee a1 = new Annee(Set.of(ue1, ue2));
        Etudiant e1 = new Etudiant("39001", "Alice", "Merveille", a1);
        e1.noter(m1, 12.0);
        e1.noter(m2, 14.0);
        e1.noter(m3, 10.0);
        System.out.println(e1);
        Etudiant e2 = new Etudiant("39002", "Bob", "Eponge", a1);
        e2.noter(m1, 14.0);
        e2.noter(m3, 14.0);
        Etudiant e3 = new Etudiant("39003", "Charles", "Chaplin", a1);
        e3.noter(m1, 18.0);
        e3.noter(m2, 5.0);
        e3.noter(m3, 14.0);
        //


    public static void main(String[]Object args;
        args) {
        question3();
        ex2();
    }
}